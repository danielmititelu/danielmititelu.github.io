import{S as Zs,i as $s,s as gs,e as l,t as r,k as c,c as o,a as i,h as p,d as t,m as f,F as Yt,b as m,g as n,J as s,G as Zt}from"../../chunks/vendor-a21aee19.js";function ea(Fs){let d,tt,ve,O,st,ke,T,at,_e,A,nt,Ee,S,lt,Be,R,ot,Le,D,it,xe,G,W,$t,He,q,rt,Pe,N,pt,Ie,U,ct,Ce,w,js=`<code class="language-cs"><span class="token class-name"><span class="token keyword">int</span></span> a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// integers ocupy 4 bytes </span>

<span class="token comment">// Little-endian (how ARM x86 and x64 architechtures work)</span>
<span class="token comment">// 0000 0110  0000 0000  0000 0000  0000 0000</span>

<span class="token comment">// Big-endian</span>
<span class="token comment">// 0000 0000  0000 0000  0000 0000  0000 0110 </span></code>`,Me,F,ft,Oe,j,mt,Te,v,zs=`<code class="language-cs"><span class="token class-name"><span class="token keyword">int</span></span> a <span class="token operator">=</span> <span class="token number">79</span><span class="token punctuation">;</span>

<span class="token comment">// binary:      0100 1111  0000 0000  0000 0000  0000 0000</span>
<span class="token comment">// haxadecimal:   4    F     0    0     0    0     0    0</span>

<span class="token comment">// haxadecimal without the spaces: 4F 00 00 00</span></code>`,Ae,z,ht,Se,h,ae,k,ut,ne,bt,dt,yt,le,_,wt,oe,vt,kt,_t,ie,E,Et,re,Bt,Lt,xt,pe,B,Ht,ce,Pt,It,Ct,fe,L,Mt,me,Ot,Tt,Re,X,J,gt,De,K,x,At,he,St,Rt,Ge,Q,V,es,We,Y,Dt,qe,Z,Gt,Ne,y,ue,Wt,qt,be,Nt,Ue,$,Ut,Fe,g,Ft,je,H,Xs=`<code class="language-cs"><span class="token class-name"><span class="token keyword">var</span></span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> bit <span class="token operator">=</span> n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// first bit is 1</span></code>`,ze,ee,jt,Xe,P,Js=`<code class="language-cs"><span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">HammingWeight</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">uint</span></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name"><span class="token keyword">int</span></span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name"><span class="token keyword">var</span></span> bit <span class="token operator">=</span> n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>bit <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> count<span class="token operator">++</span><span class="token punctuation">;</span>
        n <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>        
<span class="token punctuation">&#125;</span></code>`,Je,te,zt,Ke,u,de,I,Xt,Jt,ye,C,Kt,Qt,we,M,Vt;return{c(){d=l("h1"),tt=r("A few words about bit manipulation"),ve=c(),O=l("p"),st=r("Bit manipulation is not a technique that comes often when writing code especially when dealing with higher level languages, regardless it is useful to understand how computers work behind the scene."),ke=c(),T=l("h2"),at=r("Bit"),_e=c(),A=l("p"),nt=r("The smallest data use to represent a piece of information in computers are bits and they represent an electrical current that is stored in a memory chip. This bit can either be on or off and the notation 1 and 0 from binary system is used to denote it\u2019s state."),Ee=c(),S=l("h2"),lt=r("Byte"),Be=c(),R=l("p"),ot=r("A collection of 8 adjacent bits form a byte or octet. Since it\u2019s comprised of 8 bits that can have the value either 1 or 0, a byte can have a value in the interval [0, 255] (2 to the power of 8 or 256 values)."),Le=c(),D=l("h3"),it=r("6 representation in a byte:"),xe=c(),G=l("p"),W=l("img"),He=c(),q=l("p"),rt=r("Modern computer architechtures use memory registers of size four bytes (32-bit) or eight bytes (64-bit)."),Pe=c(),N=l("h2"),pt=r("Endianness"),Ie=c(),U=l("p"),ct=r("Endianess refers to the order the bytes are stored in a computer memory. The most common order in processor architecture is called Little-endian where the least significant byte (the byte that contains the smallest bits) is stored in the left or the smallest address memory. In contrast Big-endian will store the least significant byte on the right."),Ce=c(),w=l("pre"),Me=c(),F=l("h2"),ft=r("Hexadecimal"),Oe=c(),j=l("p"),mt=r("While binary system is used to represent the state of the memory capacitor that can only hold 2 states 1 or 0, hexadecimal system (base 16 numeral system) is usually used by memory diagnosters or when the state of the memory needs to be presented in a human readable form. One digit in hex system can represent 16 states or 4 bits which means each byte of data can represented by two hexadecimal digits."),Te=c(),v=l("pre"),Ae=c(),z=l("h2"),ht=r("Bit operations"),Se=c(),h=l("ul"),ae=l("li"),k=l("p"),ut=r("Bitwise complement ( "),ne=l("code"),bt=r("~"),dt=r(` ) ->
Caclulates the complement of a bit pattern by reversing each bit`),yt=c(),le=l("li"),_=l("p"),wt=r("Bitwise logical AND ( "),oe=l("code"),vt=r("&"),kt=r(` ) ->
Compares two operands and returns a bit pattern that shows which bits are 1 in both of them`),_t=c(),ie=l("li"),E=l("p"),Et=r("Bitwise logical OR ( "),re=l("code"),Bt=r("|"),Lt=r(` ) ->
Compares two operands and returns a bit pattern that shows which bits are 1 in either one`),xt=c(),pe=l("li"),B=l("p"),Ht=r("Bitwise logical XOR ( "),ce=l("code"),Pt=r("^"),It=r(` ) ->
Compares two operands and returns a bit pattern that shows which bits are 1 only in one of the operands`),Ct=c(),fe=l("li"),L=l("p"),Mt=r("Bitwise left shift ("),me=l("code"),Ot=r("<< x"),Tt=r(") operation will shift all bits to the left by x positions and esentially double the number for each shift."),Re=c(),X=l("p"),J=l("img"),De=c(),K=l("ul"),x=l("li"),At=r("Bitwise right shift ("),he=l("code"),St=r(">> x"),Rt=r(") operation will shift all bits to the right by x positions and esentially halve the number for each shift."),Ge=c(),Q=l("p"),V=l("img"),We=c(),Y=l("p"),Dt=r("When shifting bits left/right the left-most/right-most bit will fall in the void of nothingness and disappears out of existence (dramatic music starts playing)"),qe=c(),Z=l("h2"),Gt=r("Terminology"),Ne=c(),y=l("ul"),ue=l("li"),Wt=r("Least siginificant bit (LSB) is the right most bit"),qt=c(),be=l("li"),Nt=r("Most significant bit (MSB) is the highest or left most bit that is 1"),Ue=c(),$=l("h2"),Ut=r("Bit manipulation tricks"),Fe=c(),g=l("h4"),Ft=r("Get first bit or LSB"),je=c(),H=l("pre"),ze=c(),ee=l("h4"),jt=r("Number of ones in a bit pattern or Hamming weight"),Xe=c(),P=l("pre"),Je=c(),te=l("h2"),zt=r("Problems"),Ke=c(),u=l("ul"),de=l("li"),I=l("a"),Xt=r("https://leetcode.com/problems/sum-of-two-integers/"),Jt=c(),ye=l("li"),C=l("a"),Kt=r("https://leetcode.com/problems/number-of-1-bits/"),Qt=c(),we=l("li"),M=l("a"),Vt=r("https://leetcode.com/problems/counting-bits/"),this.h()},l(e){d=o(e,"H1",{});var a=i(d);tt=p(a,"A few words about bit manipulation"),a.forEach(t),ve=f(e),O=o(e,"P",{});var ts=i(O);st=p(ts,"Bit manipulation is not a technique that comes often when writing code especially when dealing with higher level languages, regardless it is useful to understand how computers work behind the scene."),ts.forEach(t),ke=f(e),T=o(e,"H2",{});var ss=i(T);at=p(ss,"Bit"),ss.forEach(t),_e=f(e),A=o(e,"P",{});var as=i(A);nt=p(as,"The smallest data use to represent a piece of information in computers are bits and they represent an electrical current that is stored in a memory chip. This bit can either be on or off and the notation 1 and 0 from binary system is used to denote it\u2019s state."),as.forEach(t),Ee=f(e),S=o(e,"H2",{});var ns=i(S);lt=p(ns,"Byte"),ns.forEach(t),Be=f(e),R=o(e,"P",{});var ls=i(R);ot=p(ls,"A collection of 8 adjacent bits form a byte or octet. Since it\u2019s comprised of 8 bits that can have the value either 1 or 0, a byte can have a value in the interval [0, 255] (2 to the power of 8 or 256 values)."),ls.forEach(t),Le=f(e),D=o(e,"H3",{});var os=i(D);it=p(os,"6 representation in a byte:"),os.forEach(t),xe=f(e),G=o(e,"P",{});var is=i(G);W=o(is,"IMG",{src:!0,alt:!0}),is.forEach(t),He=f(e),q=o(e,"P",{});var rs=i(q);rt=p(rs,"Modern computer architechtures use memory registers of size four bytes (32-bit) or eight bytes (64-bit)."),rs.forEach(t),Pe=f(e),N=o(e,"H2",{});var ps=i(N);pt=p(ps,"Endianness"),ps.forEach(t),Ie=f(e),U=o(e,"P",{});var cs=i(U);ct=p(cs,"Endianess refers to the order the bytes are stored in a computer memory. The most common order in processor architecture is called Little-endian where the least significant byte (the byte that contains the smallest bits) is stored in the left or the smallest address memory. In contrast Big-endian will store the least significant byte on the right."),cs.forEach(t),Ce=f(e),w=o(e,"PRE",{class:!0});var Ks=i(w);Ks.forEach(t),Me=f(e),F=o(e,"H2",{});var fs=i(F);ft=p(fs,"Hexadecimal"),fs.forEach(t),Oe=f(e),j=o(e,"P",{});var ms=i(j);mt=p(ms,"While binary system is used to represent the state of the memory capacitor that can only hold 2 states 1 or 0, hexadecimal system (base 16 numeral system) is usually used by memory diagnosters or when the state of the memory needs to be presented in a human readable form. One digit in hex system can represent 16 states or 4 bits which means each byte of data can represented by two hexadecimal digits."),ms.forEach(t),Te=f(e),v=o(e,"PRE",{class:!0});var Qs=i(v);Qs.forEach(t),Ae=f(e),z=o(e,"H2",{});var hs=i(z);ht=p(hs,"Bit operations"),hs.forEach(t),Se=f(e),h=o(e,"UL",{});var b=i(h);ae=o(b,"LI",{});var us=i(ae);k=o(us,"P",{});var Qe=i(k);ut=p(Qe,"Bitwise complement ( "),ne=o(Qe,"CODE",{});var bs=i(ne);bt=p(bs,"~"),bs.forEach(t),dt=p(Qe,` ) ->
Caclulates the complement of a bit pattern by reversing each bit`),Qe.forEach(t),us.forEach(t),yt=f(b),le=o(b,"LI",{});var ds=i(le);_=o(ds,"P",{});var Ve=i(_);wt=p(Ve,"Bitwise logical AND ( "),oe=o(Ve,"CODE",{});var ys=i(oe);vt=p(ys,"&"),ys.forEach(t),kt=p(Ve,` ) ->
Compares two operands and returns a bit pattern that shows which bits are 1 in both of them`),Ve.forEach(t),ds.forEach(t),_t=f(b),ie=o(b,"LI",{});var ws=i(ie);E=o(ws,"P",{});var Ye=i(E);Et=p(Ye,"Bitwise logical OR ( "),re=o(Ye,"CODE",{});var vs=i(re);Bt=p(vs,"|"),vs.forEach(t),Lt=p(Ye,` ) ->
Compares two operands and returns a bit pattern that shows which bits are 1 in either one`),Ye.forEach(t),ws.forEach(t),xt=f(b),pe=o(b,"LI",{});var ks=i(pe);B=o(ks,"P",{});var Ze=i(B);Ht=p(Ze,"Bitwise logical XOR ( "),ce=o(Ze,"CODE",{});var _s=i(ce);Pt=p(_s,"^"),_s.forEach(t),It=p(Ze,` ) ->
Compares two operands and returns a bit pattern that shows which bits are 1 only in one of the operands`),Ze.forEach(t),ks.forEach(t),Ct=f(b),fe=o(b,"LI",{});var Es=i(fe);L=o(Es,"P",{});var $e=i(L);Mt=p($e,"Bitwise left shift ("),me=o($e,"CODE",{});var Bs=i(me);Ot=p(Bs,"<< x"),Bs.forEach(t),Tt=p($e,") operation will shift all bits to the left by x positions and esentially double the number for each shift."),$e.forEach(t),Es.forEach(t),b.forEach(t),Re=f(e),X=o(e,"P",{});var Ls=i(X);J=o(Ls,"IMG",{src:!0,alt:!0}),Ls.forEach(t),De=f(e),K=o(e,"UL",{});var xs=i(K);x=o(xs,"LI",{});var ge=i(x);At=p(ge,"Bitwise right shift ("),he=o(ge,"CODE",{});var Hs=i(he);St=p(Hs,">> x"),Hs.forEach(t),Rt=p(ge,") operation will shift all bits to the right by x positions and esentially halve the number for each shift."),ge.forEach(t),xs.forEach(t),Ge=f(e),Q=o(e,"P",{});var Ps=i(Q);V=o(Ps,"IMG",{src:!0,alt:!0}),Ps.forEach(t),We=f(e),Y=o(e,"P",{});var Is=i(Y);Dt=p(Is,"When shifting bits left/right the left-most/right-most bit will fall in the void of nothingness and disappears out of existence (dramatic music starts playing)"),Is.forEach(t),qe=f(e),Z=o(e,"H2",{});var Cs=i(Z);Gt=p(Cs,"Terminology"),Cs.forEach(t),Ne=f(e),y=o(e,"UL",{});var et=i(y);ue=o(et,"LI",{});var Ms=i(ue);Wt=p(Ms,"Least siginificant bit (LSB) is the right most bit"),Ms.forEach(t),qt=f(et),be=o(et,"LI",{});var Os=i(be);Nt=p(Os,"Most significant bit (MSB) is the highest or left most bit that is 1"),Os.forEach(t),et.forEach(t),Ue=f(e),$=o(e,"H2",{});var Ts=i($);Ut=p(Ts,"Bit manipulation tricks"),Ts.forEach(t),Fe=f(e),g=o(e,"H4",{});var As=i(g);Ft=p(As,"Get first bit or LSB"),As.forEach(t),je=f(e),H=o(e,"PRE",{class:!0});var Vs=i(H);Vs.forEach(t),ze=f(e),ee=o(e,"H4",{});var Ss=i(ee);jt=p(Ss,"Number of ones in a bit pattern or Hamming weight"),Ss.forEach(t),Xe=f(e),P=o(e,"PRE",{class:!0});var Ys=i(P);Ys.forEach(t),Je=f(e),te=o(e,"H2",{});var Rs=i(te);zt=p(Rs,"Problems"),Rs.forEach(t),Ke=f(e),u=o(e,"UL",{});var se=i(u);de=o(se,"LI",{});var Ds=i(de);I=o(Ds,"A",{href:!0,rel:!0});var Gs=i(I);Xt=p(Gs,"https://leetcode.com/problems/sum-of-two-integers/"),Gs.forEach(t),Ds.forEach(t),Jt=f(se),ye=o(se,"LI",{});var Ws=i(ye);C=o(Ws,"A",{href:!0,rel:!0});var qs=i(C);Kt=p(qs,"https://leetcode.com/problems/number-of-1-bits/"),qs.forEach(t),Ws.forEach(t),Qt=f(se),we=o(se,"LI",{});var Ns=i(we);M=o(Ns,"A",{href:!0,rel:!0});var Us=i(M);Vt=p(Us,"https://leetcode.com/problems/counting-bits/"),Us.forEach(t),Ns.forEach(t),se.forEach(t),this.h()},h(){Yt(W.src,$t="/bits.svg")||m(W,"src",$t),m(W,"alt","image"),m(w,"class","language-cs"),m(v,"class","language-cs"),Yt(J.src,gt="/left-shift.svg")||m(J,"src",gt),m(J,"alt","image"),Yt(V.src,es="/right-shift.svg")||m(V,"src",es),m(V,"alt","image"),m(H,"class","language-cs"),m(P,"class","language-cs"),m(I,"href","https://leetcode.com/problems/sum-of-two-integers/"),m(I,"rel","nofollow"),m(C,"href","https://leetcode.com/problems/number-of-1-bits/"),m(C,"rel","nofollow"),m(M,"href","https://leetcode.com/problems/counting-bits/"),m(M,"rel","nofollow")},m(e,a){n(e,d,a),s(d,tt),n(e,ve,a),n(e,O,a),s(O,st),n(e,ke,a),n(e,T,a),s(T,at),n(e,_e,a),n(e,A,a),s(A,nt),n(e,Ee,a),n(e,S,a),s(S,lt),n(e,Be,a),n(e,R,a),s(R,ot),n(e,Le,a),n(e,D,a),s(D,it),n(e,xe,a),n(e,G,a),s(G,W),n(e,He,a),n(e,q,a),s(q,rt),n(e,Pe,a),n(e,N,a),s(N,pt),n(e,Ie,a),n(e,U,a),s(U,ct),n(e,Ce,a),n(e,w,a),w.innerHTML=js,n(e,Me,a),n(e,F,a),s(F,ft),n(e,Oe,a),n(e,j,a),s(j,mt),n(e,Te,a),n(e,v,a),v.innerHTML=zs,n(e,Ae,a),n(e,z,a),s(z,ht),n(e,Se,a),n(e,h,a),s(h,ae),s(ae,k),s(k,ut),s(k,ne),s(ne,bt),s(k,dt),s(h,yt),s(h,le),s(le,_),s(_,wt),s(_,oe),s(oe,vt),s(_,kt),s(h,_t),s(h,ie),s(ie,E),s(E,Et),s(E,re),s(re,Bt),s(E,Lt),s(h,xt),s(h,pe),s(pe,B),s(B,Ht),s(B,ce),s(ce,Pt),s(B,It),s(h,Ct),s(h,fe),s(fe,L),s(L,Mt),s(L,me),s(me,Ot),s(L,Tt),n(e,Re,a),n(e,X,a),s(X,J),n(e,De,a),n(e,K,a),s(K,x),s(x,At),s(x,he),s(he,St),s(x,Rt),n(e,Ge,a),n(e,Q,a),s(Q,V),n(e,We,a),n(e,Y,a),s(Y,Dt),n(e,qe,a),n(e,Z,a),s(Z,Gt),n(e,Ne,a),n(e,y,a),s(y,ue),s(ue,Wt),s(y,qt),s(y,be),s(be,Nt),n(e,Ue,a),n(e,$,a),s($,Ut),n(e,Fe,a),n(e,g,a),s(g,Ft),n(e,je,a),n(e,H,a),H.innerHTML=Xs,n(e,ze,a),n(e,ee,a),s(ee,jt),n(e,Xe,a),n(e,P,a),P.innerHTML=Js,n(e,Je,a),n(e,te,a),s(te,zt),n(e,Ke,a),n(e,u,a),s(u,de),s(de,I),s(I,Xt),s(u,Jt),s(u,ye),s(ye,C),s(C,Kt),s(u,Qt),s(u,we),s(we,M),s(M,Vt)},p:Zt,i:Zt,o:Zt,d(e){e&&t(d),e&&t(ve),e&&t(O),e&&t(ke),e&&t(T),e&&t(_e),e&&t(A),e&&t(Ee),e&&t(S),e&&t(Be),e&&t(R),e&&t(Le),e&&t(D),e&&t(xe),e&&t(G),e&&t(He),e&&t(q),e&&t(Pe),e&&t(N),e&&t(Ie),e&&t(U),e&&t(Ce),e&&t(w),e&&t(Me),e&&t(F),e&&t(Oe),e&&t(j),e&&t(Te),e&&t(v),e&&t(Ae),e&&t(z),e&&t(Se),e&&t(h),e&&t(Re),e&&t(X),e&&t(De),e&&t(K),e&&t(Ge),e&&t(Q),e&&t(We),e&&t(Y),e&&t(qe),e&&t(Z),e&&t(Ne),e&&t(y),e&&t(Ue),e&&t($),e&&t(Fe),e&&t(g),e&&t(je),e&&t(H),e&&t(ze),e&&t(ee),e&&t(Xe),e&&t(P),e&&t(Je),e&&t(te),e&&t(Ke),e&&t(u)}}}const sa={title:"A few words about bit manipulation",tags:["blog"]};class aa extends Zs{constructor(d){super();$s(this,d,null,ea,gs,{})}}export{aa as default,sa as metadata};
