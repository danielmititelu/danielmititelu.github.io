<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Algorithms on Home</title><link>https://danielmititelu.github.io/algorithms/</link><description>Recent content in Algorithms on Home</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 10 Oct 2022 19:40:42 +0300</lastBuildDate><atom:link href="https://danielmititelu.github.io/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Dijkstra's Algorithm</title><link>https://danielmititelu.github.io/algorithms/dijkstra-algorithm/</link><pubDate>Mon, 10 Oct 2022 19:40:42 +0300</pubDate><guid>https://danielmititelu.github.io/algorithms/dijkstra-algorithm/</guid><description>Greedy algorithm used to find the shortest path in a weighted graph.
Undirected Single source shortest paths with positive integer weights in linear time
Time complexity: O(V + Elog(E))
Space complexity: O(V + E)
Restrictions: only for non-decreasing weights (all weights &amp;gt;= 0)
private Dictionary&amp;lt;int, int&amp;gt; Dijkstra( Dictionary&amp;lt;int, List&amp;lt;(int dest, int dist)&amp;gt;&amp;gt; graph, int source /*, int target*/) { var minHeap = new PriorityQueue&amp;lt;(int node, int dist), int&amp;gt;(); var distances = new Dictionary&amp;lt;int, int&amp;gt;(); var visited = new HashSet&amp;lt;int&amp;gt;(); // initialize every node with infinity foreach (var node in graph.</description></item><item><title>Binary tree traversals</title><link>https://danielmititelu.github.io/algorithms/binary-tree-traversals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/binary-tree-traversals/</guid><description>Preorder traversal Order of visiting: parent -&amp;gt; left child -&amp;gt; right child
Recursive implementation:
public IList&amp;lt;int&amp;gt; PreorderTraversal(TreeNode root) { var result = new List&amp;lt;int&amp;gt;(); Preorder(root, result); return result; } public void Preorder(TreeNode node, IList&amp;lt;int&amp;gt; result) { if(node == null) return; result.Add(node.val); Preorder(node.left, result); Preorder(node.right, result); } Iterative implementation:
public IList&amp;lt;int&amp;gt; PreorderTraversal(TreeNode root) { var res = new List&amp;lt;int&amp;gt;(); if (root == null) return res; var stack = new Stack&amp;lt;TreeNode&amp;gt;(); stack.Push(root); while (stack.</description></item><item><title>Boyer-Moore Voting Algorithm</title><link>https://danielmititelu.github.io/algorithms/voting-algo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/voting-algo/</guid><description>Time complexity : O(n) Space complexity : O(1)
The algorithm counts the majority of votes(elements) in an array by finding a part of the array (suffix) where the first element in array suffix is the majority. It does this by diregarding any prefix where the majority is equal to the minority of votes.
public int MajorityElement(int[] nums) { int count = 0; int candidate = 0; foreach (int num in nums) { if (count == 0) { candidate = num; } count += (num == candidate) ?</description></item><item><title>Cycle detection</title><link>https://danielmititelu.github.io/algorithms/cycle-detection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/cycle-detection/</guid><description>public enum Colors { White, Gray, Black } public bool HasCycle(int[][] graph, int start, Colors[] colors) { if(colors[start] == Colors.Gray) return true; if(colors[start] == Colors.Black) return false; colors[start] = Colors.Gray; foreach(var neighbor in graph[start]) { if(HasCycle(graph, neighbor, colors)) return true; } colors[start] = Colors.Black; return false; } Problems https://leetcode.com/problems/find-eventual-safe-states</description></item><item><title>Graph traversals</title><link>https://danielmititelu.github.io/algorithms/graph-traversals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/graph-traversals/</guid><description>Breadth-first search We scan through the graph level by level starting with the nodes closest to the starting node.
Examples: BFS can only be implemented in iterative manner: public void BFS(Node node) { var queue = new Queue&amp;lt;Node&amp;gt;(); queue.Enqueue(node); while(queue.Count &amp;gt; 0) { const current = queue.Dequeue(); // visit node node.Visited = true; foreach(var child of node.Children) if(!child.Visited) stack.Enqueue(child); } } Depth-first search DFS for short is going to search a graph or matrix by depth first meaning it will pick a direction and go in that direction before coming back to visit other directions</description></item><item><title>Kruskal's Algorithm</title><link>https://danielmititelu.github.io/algorithms/kruskal-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/kruskal-algorithm/</guid><description>Greedy alghorithm used to find the minimum spanning tree of a given graph
Time complexity: O(Elog(E))
Space complexity: O(E + V)
Minimum spanning tree A Minimum spanning tree(MST for short) is a subgraph of a cyclic, undirected graph that will connected all the vertices and contain no cycles.
Number of edges of the MST is equal to V - 1 where V is the number of vertices of the bigger graph</description></item><item><title>Multi-source Bread-first search</title><link>https://danielmititelu.github.io/algorithms/multi-source-bfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/multi-source-bfs/</guid><description>Leetcode problems https://leetcode.com/problems/01-matrix/ https://leetcode.com/problems/rotting-oranges/</description></item><item><title>Quickselect</title><link>https://danielmititelu.github.io/algorithms/quick-select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/quick-select/</guid><description>Quick select or Hoare&amp;rsquo;s selection algorithm Time complexity: - average case O(N) - worst case O(N^2)
Algoritm steps:
figure out k-th index(smallest: k, biggest: n - k) add 2 pointers (left and right) for the start and end of the array, similar to binary search while left is smaller than right pick a random index as pivot and partition: save the pivot in the right pointer starting from left with 2 pointers: storeIndex and i: move i forword untill it reaches the right pointer, every time i finds a value smaller than the pivot, swap it with storeIndex and increment storeIndex at the end swap storeIndex with the pivot stored in right pointer return storeIndex, this is our pivot in it&amp;rsquo;s final ordered position similar to binary search compare pivot index with the k-th index: if they are equal then we found the k-th element if pivot index is bigger, seach in the left part of the pivot where there are smaller values if pivot index is smaller, search in the right part int FindKthLargest(int[] nums, int k) { var kthIndex = nums.</description></item><item><title>Three way partitioning</title><link>https://danielmititelu.github.io/algorithms/three-way-partitioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/three-way-partitioning/</guid><description>A partition strategy that is sometime used in quicksort.
Code example Dutch national flag problem // Dutch national flag problem (partition array into 3 parts: red, white, blue) // 0 -&amp;gt; red, 1 -&amp;gt; white, 2 -&amp;gt; blue void SortColors(int[] nums) { int red = 0, white = 0, blue = nums.Length - 1; // Traverse the array until we hit the blue part while(white &amp;lt;= blue) { // if the white iterator hit a red color // swap it with the red iterator and increment it // and the white iterator if(nums[white] == 0) { Swap(nums, red, white); red++; white++; } // if the white iterator hit a blue color // swap it with the blue iterator and // decrement the blue iterator else if(nums[white] == 2) { Swap(nums, white, blue); blue--; } // if white iterator hit a white color // it&amp;#39;s already in the right place // so just increase the white iterator else { white++; } } } void Swap(int[] nums, int left, int i) { int temp = nums[left]; nums[left] = nums[i]; nums[i] = temp; } Partition around a range // Function to partition the array around the range such // that array is divided into three parts.</description></item><item><title>Topological sort</title><link>https://danielmititelu.github.io/algorithms/topological-sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/topological-sort/</guid><description>Time Complexity: O(V+E) // V = vertex (or node), E = edge
Sort a graph so that any node on the left will point only to the nodes in the right
cannot be done for graphs that have a cycle should be a DAG(directed acyclic graph) Khan&amp;rsquo;s algorithm
private List&amp;lt;int&amp;gt; TopologicalSort(Dictionary&amp;lt;int, List&amp;lt;int&amp;gt;&amp;gt; graph) { var indegrees = CountIndegrees(graph); var queue = new Queue&amp;lt;int&amp;gt;(); foreach(var (course, count) in indegrees) { if(count == 0) { queue.</description></item></channel></rss>