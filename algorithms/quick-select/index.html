<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Quickselect | Home</title><meta name=keywords content="algorithm"><meta name=description content="Quick select or Hoare&rsquo;s selection algorithm Time complexity: - average case O(N) - worst case O(N^2)
Algoritm steps:
figure out k-th index(smallest: k, biggest: n - k) add 2 pointers (left and right) for the start and end of the array, similar to binary search while left is smaller than right pick a random index as pivot and partition: save the pivot in the right pointer starting from left with 2 pointers: storeIndex and i: move i forword untill it reaches the right pointer, every time i finds a value smaller than the pivot, swap it with storeIndex and increment storeIndex at the end swap storeIndex with the pivot stored in right pointer return storeIndex, this is our pivot in it&rsquo;s final ordered position similar to binary search compare pivot index with the k-th index: if they are equal then we found the k-th element if pivot index is bigger, seach in the left part of the pivot where there are smaller values if pivot index is smaller, search in the right part int FindKthLargest(int[] nums, int k) { var kthIndex = nums."><meta name=author content><link rel=canonical href=https://danielmititelu.github.io/algorithms/quick-select/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://danielmititelu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://danielmititelu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://danielmititelu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://danielmititelu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://danielmititelu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://danielmititelu.github.io/style.css><meta property="og:title" content="Quickselect"><meta property="og:description" content="Quick select or Hoare&rsquo;s selection algorithm Time complexity: - average case O(N) - worst case O(N^2)
Algoritm steps:
figure out k-th index(smallest: k, biggest: n - k) add 2 pointers (left and right) for the start and end of the array, similar to binary search while left is smaller than right pick a random index as pivot and partition: save the pivot in the right pointer starting from left with 2 pointers: storeIndex and i: move i forword untill it reaches the right pointer, every time i finds a value smaller than the pivot, swap it with storeIndex and increment storeIndex at the end swap storeIndex with the pivot stored in right pointer return storeIndex, this is our pivot in it&rsquo;s final ordered position similar to binary search compare pivot index with the k-th index: if they are equal then we found the k-th element if pivot index is bigger, seach in the left part of the pivot where there are smaller values if pivot index is smaller, search in the right part int FindKthLargest(int[] nums, int k) { var kthIndex = nums."><meta property="og:type" content="article"><meta property="og:url" content="https://danielmititelu.github.io/algorithms/quick-select/"><meta property="article:section" content="algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="Quickselect"><meta name=twitter:description content="Quick select or Hoare&rsquo;s selection algorithm Time complexity: - average case O(N) - worst case O(N^2)
Algoritm steps:
figure out k-th index(smallest: k, biggest: n - k) add 2 pointers (left and right) for the start and end of the array, similar to binary search while left is smaller than right pick a random index as pivot and partition: save the pivot in the right pointer starting from left with 2 pointers: storeIndex and i: move i forword untill it reaches the right pointer, every time i finds a value smaller than the pivot, swap it with storeIndex and increment storeIndex at the end swap storeIndex with the pivot stored in right pointer return storeIndex, this is our pivot in it&rsquo;s final ordered position similar to binary search compare pivot index with the k-th index: if they are equal then we found the k-th element if pivot index is bigger, seach in the left part of the pivot where there are smaller values if pivot index is smaller, search in the right part int FindKthLargest(int[] nums, int k) { var kthIndex = nums."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Algorithms","item":"https://danielmititelu.github.io/algorithms/"},{"@type":"ListItem","position":2,"name":"Quickselect","item":"https://danielmititelu.github.io/algorithms/quick-select/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Quickselect","name":"Quickselect","description":"Quick select or Hoare\u0026rsquo;s selection algorithm Time complexity: - average case O(N) - worst case O(N^2)\nAlgoritm steps:\nfigure out k-th index(smallest: k, biggest: n - k) add 2 pointers (left and right) for the start and end of the array, similar to binary search while left is smaller than right pick a random index as pivot and partition: save the pivot in the right pointer starting from left with 2 pointers: storeIndex and i: move i forword untill it reaches the right pointer, every time i finds a value smaller than the pivot, swap it with storeIndex and increment storeIndex at the end swap storeIndex with the pivot stored in right pointer return storeIndex, this is our pivot in it\u0026rsquo;s final ordered position similar to binary search compare pivot index with the k-th index: if they are equal then we found the k-th element if pivot index is bigger, seach in the left part of the pivot where there are smaller values if pivot index is smaller, search in the right part int FindKthLargest(int[] nums, int k) { var kthIndex = nums.","keywords":["algorithm"],"articleBody":"Quick select or Hoare’s selection algorithm Time complexity: - average case O(N) - worst case O(N^2)\nAlgoritm steps:\nfigure out k-th index(smallest: k, biggest: n - k) add 2 pointers (left and right) for the start and end of the array, similar to binary search while left is smaller than right pick a random index as pivot and partition: save the pivot in the right pointer starting from left with 2 pointers: storeIndex and i: move i forword untill it reaches the right pointer, every time i finds a value smaller than the pivot, swap it with storeIndex and increment storeIndex at the end swap storeIndex with the pivot stored in right pointer return storeIndex, this is our pivot in it’s final ordered position similar to binary search compare pivot index with the k-th index: if they are equal then we found the k-th element if pivot index is bigger, seach in the left part of the pivot where there are smaller values if pivot index is smaller, search in the right part int FindKthLargest(int[] nums, int k) { var kthIndex = nums.Length - k; var left = 0; var right = nums.Length - 1; while (left \u003c right) { var pivotIdx = Partition(nums, left, right); if (pivotIdx == kthIndex) break; else if (pivotIdx \u003c kthIndex) left = pivotIdx + 1; else right = pivotIdx - 1; } return nums[kthIndex]; } int Partition(int[] nums, int left, int right) { var pivotIdx = new Random().Next(left, right); Swap(nums, pivotIdx, right); var storeIndex = left; for (var i = left; i \u003c right; i++) { if (nums[i] \u003c nums[right]) { Swap(nums, i, storeIndex); storeIndex++; } } Swap(nums, storeIndex, right); return storeIndex; } void Swap(int[] nums, int pivot, int right) { var temp = nums[pivot]; nums[pivot] = nums[right]; nums[right] = temp; } ","wordCount":"298","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://danielmititelu.github.io/algorithms/quick-select/"},"publisher":{"@type":"Organization","name":"Home","logo":{"@type":"ImageObject","url":"https://danielmititelu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://danielmititelu.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Quickselect</h1><div class=post-meta></div></header><div class=post-content><h3 id=quick-select-or-hoares-selection-algorithm>Quick select or Hoare&rsquo;s selection algorithm<a hidden class=anchor aria-hidden=true href=#quick-select-or-hoares-selection-algorithm>#</a></h3><p>Time complexity:
- average case O(N)
- worst case O(N^2)</p><p>Algoritm steps:</p><ul><li>figure out k-th index(smallest: k, biggest: n - k)</li><li>add 2 pointers (<code>left</code> and <code>right</code>) for the start and end of the array, similar to binary search</li><li>while <code>left</code> is smaller than <code>right</code> pick a random index as pivot and partition:<ul><li>save the pivot in the right pointer</li><li>starting from left with 2 pointers: <code>storeIndex</code> and <code>i</code>:<ul><li>move <code>i</code> forword untill it reaches the right pointer,</li><li>every time <code>i</code> finds a value smaller than the pivot, swap it with <code>storeIndex</code> and increment <code>storeIndex</code></li><li>at the end swap <code>storeIndex</code> with the pivot stored in right pointer</li><li>return <code>storeIndex</code>, this is our pivot in it&rsquo;s final ordered position</li></ul></li></ul></li><li>similar to binary search compare pivot index with the k-th index:<ul><li>if they are equal then we found the k-th element</li><li>if pivot index is bigger, seach in the left part of the pivot where there are smaller values</li><li>if pivot index is smaller, search in the right part</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span> FindKthLargest(<span style=color:#66d9ef>int</span>[] nums, <span style=color:#66d9ef>int</span> k)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> kthIndex = nums.Length - k;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> left = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> right = nums.Length - <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (left &lt; right)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> pivotIdx = Partition(nums, left, right);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pivotIdx == kthIndex)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pivotIdx &lt; kthIndex)
</span></span><span style=display:flex><span>            left = pivotIdx + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            right = pivotIdx - <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> nums[kthIndex];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> Partition(<span style=color:#66d9ef>int</span>[] nums, <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> pivotIdx = <span style=color:#66d9ef>new</span> Random().Next(left, right);
</span></span><span style=display:flex><span>    Swap(nums, pivotIdx, right);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> storeIndex = left;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> i = left; i &lt; right; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nums[i] &lt; nums[right])
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Swap(nums, i, storeIndex);
</span></span><span style=display:flex><span>            storeIndex++;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Swap(nums, storeIndex, right);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> storeIndex;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Swap(<span style=color:#66d9ef>int</span>[] nums, <span style=color:#66d9ef>int</span> pivot, <span style=color:#66d9ef>int</span> right)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> temp = nums[pivot];
</span></span><span style=display:flex><span>    nums[pivot] = nums[right];
</span></span><span style=display:flex><span>    nums[right] = temp;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://danielmititelu.github.io/tags/algorithm/>algorithm</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://danielmititelu.github.io/>Home</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>