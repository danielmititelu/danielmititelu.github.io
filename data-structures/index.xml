<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Data-structures on Home</title><link>https://danielmititelu.github.io/data-structures/</link><description>Recent content in Data-structures on Home</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 30 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://danielmititelu.github.io/data-structures/index.xml" rel="self" type="application/rss+xml"/><item><title>Trie</title><link>https://danielmititelu.github.io/data-structures/trie/</link><pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/data-structures/trie/</guid><description>A trie or prefix tree is tree data structure that allows for fast searching of a key or string prefix in a dataset of strings. It is used in word completion like google search or intellisense
Example implementation public class Trie { private Node _root; public Trie() { _root = new Node(); } public void Insert(string word) { var node = _root; foreach(char c in word) { if(!node.Children.ContainsKey(c)) { node.Children[c] = new Node(); } node = node.</description></item><item><title>Disjoint sets</title><link>https://danielmititelu.github.io/data-structures/disjoint-sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/data-structures/disjoint-sets/</guid><description>Disjoint Sets or Union find is a data structure used for finding relationships between nodes.
For example disjointed sets are ideal for the following scenarios:
find if a person is a direct or indirect friend of another person in a social platform given a list of flights find if there is a way to reach a destination starting from a given city Disjoint Sets or Union find implements 2 methods:</description></item><item><title>Hash map</title><link>https://danielmititelu.github.io/data-structures/hashmap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/data-structures/hashmap/</guid><description>Time complexity: - average case: insert, lookup O(1) - worst case: insert, lookup O(N)
A hash map, hash table or dictionary organizes data in key/value pairs with constant lookup time for the keys. It is similar to an array where indexes are used to access values but the key difference (no pun intended) is that any type of object can be used as the key and not just integers.
In fact hash tables are built with array as the backing field but in order to support strings or custom object in keys a hashing function is used to convert the string/custom object to an integer index.</description></item><item><title>Heap</title><link>https://danielmititelu.github.io/data-structures/heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/data-structures/heap/</guid><description>A heap is a complete binary tree where the any given node is smaller/bigger than it&amp;rsquo;s descendents depending if it&amp;rsquo;s a min/max heap
Heap represented as array A heap can easily be represented as an array:
add in array level by level if a given node is at index i to find the parent of a node: p = (i - 1) / 2 (floor value of i/2) left chlid = 2 * i + 1 right child = 2 * i + 2 all leaf nodes are in the last half of the array Insert a value in the heap add element at the end of array compare with parent and swap if it&amp;rsquo;s smaller/bigger repeat for all parents of that node Extract min/max value from heap get value from root bring the right-most leaf(last element of array) in the root push the element down by comparing with it&amp;rsquo;s children and swapping if neccesary (or [[Heapify]]) public class MinHeap { private List&amp;lt;int&amp;gt; _heap; public MinHeap() { _heap = new List&amp;lt;int&amp;gt;(); } public void Insert(int value) { _heap.</description></item></channel></rss>