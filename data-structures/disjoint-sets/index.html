<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Disjoint sets | Home</title><meta name=keywords content="data-structure"><meta name=description content="Disjoint Sets or Union find is a data structure used for finding relationships between nodes.
For example disjointed sets are ideal for the following scenarios:
find if a person is a direct or indirect friend of another person in a social platform given a list of flights find if there is a way to reach a destination starting from a given city Disjoint Sets or Union find implements 2 methods:"><meta name=author content><link rel=canonical href=https://danielmititelu.github.io/data-structures/disjoint-sets/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://danielmititelu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://danielmititelu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://danielmititelu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://danielmititelu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://danielmititelu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://danielmititelu.github.io/style.css><meta property="og:title" content="Disjoint sets"><meta property="og:description" content="Disjoint Sets or Union find is a data structure used for finding relationships between nodes.
For example disjointed sets are ideal for the following scenarios:
find if a person is a direct or indirect friend of another person in a social platform given a list of flights find if there is a way to reach a destination starting from a given city Disjoint Sets or Union find implements 2 methods:"><meta property="og:type" content="article"><meta property="og:url" content="https://danielmititelu.github.io/data-structures/disjoint-sets/"><meta property="article:section" content="data-structures"><meta name=twitter:card content="summary"><meta name=twitter:title content="Disjoint sets"><meta name=twitter:description content="Disjoint Sets or Union find is a data structure used for finding relationships between nodes.
For example disjointed sets are ideal for the following scenarios:
find if a person is a direct or indirect friend of another person in a social platform given a list of flights find if there is a way to reach a destination starting from a given city Disjoint Sets or Union find implements 2 methods:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Data-structures","item":"https://danielmititelu.github.io/data-structures/"},{"@type":"ListItem","position":2,"name":"Disjoint sets","item":"https://danielmititelu.github.io/data-structures/disjoint-sets/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Disjoint sets","name":"Disjoint sets","description":"Disjoint Sets or Union find is a data structure used for finding relationships between nodes.\nFor example disjointed sets are ideal for the following scenarios:\nfind if a person is a direct or indirect friend of another person in a social platform given a list of flights find if there is a way to reach a destination starting from a given city Disjoint Sets or Union find implements 2 methods:","keywords":["data-structure"],"articleBody":"Disjoint Sets or Union find is a data structure used for finding relationships between nodes.\nFor example disjointed sets are ideal for the following scenarios:\nfind if a person is a direct or indirect friend of another person in a social platform given a list of flights find if there is a way to reach a destination starting from a given city Disjoint Sets or Union find implements 2 methods:\nfind - returns the union representative union - connects two nodes Time complexity for both find and union is smaller than O(log n) or amortized O(1) if union by rank and path compression is used.\nAn array is used to represent the parents of the disjointed sets. This is how the parents array would look after the union operation is performed on the blue and red nodes:\nOptimizations Path compression An optimization that aims to flatten the traversal tree to the height of one so that all find operation would be completed in constant time.\nUnion by rank This optimization aims to always attached the smaller tree to the bigger one. An additional array is required to store the ranks of each tree.\nCode example: public class DisjointSets { private int[] _parents; private int[] _ranks; public int Count { get; set; } public DisjointSets(int n) { _parents = new int[n]; _ranks = new int[n]; Count = n; for(var i = 0; i \u003c n; i++) { _parents[i] = i; _ranks[i] = 1; } } public int Find(int x) { if (_parents[x] == x) { return x; } // path compression _parents[x] = Find(_parents[x]); return _parents[x]; } public void Union(int x, int y) { int xRoot = Find(x); int yRoot = Find(y); if (xRoot == yRoot) { return; } // union by rank if (_ranks[xRoot] \u003c _ranks[yRoot]) { _parents[xRoot] = yRoot; } else if (_ranks[xRoot] \u003e _ranks[yRoot]) { _parents[yRoot] = xRoot; } else { _parents[yRoot] = xRoot; _ranks[xRoot] += 1; } Count--; } } Problems that could be solved with union find https://leetcode.com/problems/number-of-provinces/ https://leetcode.com/problems/longest-consecutive-sequence/ https://leetcode.com/problems/accounts-merge/ https://leetcode.com/problems/redundant-connection/ ","wordCount":"335","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://danielmititelu.github.io/data-structures/disjoint-sets/"},"publisher":{"@type":"Organization","name":"Home","logo":{"@type":"ImageObject","url":"https://danielmititelu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://danielmititelu.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Disjoint sets</h1><div class=post-meta></div></header><div class=post-content><p>Disjoint Sets or Union find is a data structure used for finding relationships between nodes.</p><p>For example disjointed sets are ideal for the following scenarios:</p><ul><li>find if a person is a direct or indirect friend of another person in a social platform</li><li>given a list of flights find if there is a way to reach a destination starting from a given city</li></ul><p>Disjoint Sets or Union find implements 2 methods:</p><ul><li>find - returns the union representative</li><li>union - connects two nodes</li></ul><p>Time complexity for both find and union is smaller than O(log n) or amortized O(1) if union by rank and path compression is used.</p><p>An array is used to represent the parents of the disjointed sets. This is how the parents array would look after the union operation is performed on the blue and red nodes:</p><p><img loading=lazy src=img/disjoint-sets.svg alt="Disjoint sets representation"></p><h2 id=optimizations>Optimizations<a hidden class=anchor aria-hidden=true href=#optimizations>#</a></h2><h4 id=path-compression>Path compression<a hidden class=anchor aria-hidden=true href=#path-compression>#</a></h4><p>An optimization that aims to flatten the traversal tree to the height of one so that all find operation would be completed in constant time.</p><h4 id=union-by-rank>Union by rank<a hidden class=anchor aria-hidden=true href=#union-by-rank>#</a></h4><p>This optimization aims to always attached the smaller tree to the bigger one. An additional array is required to store the ranks of each tree.</p><p><img loading=lazy src=img/disjoint-sets-completed.svg alt="Completed disjointed sets"></p><h4 id=code-example>Code example:<a hidden class=anchor aria-hidden=true href=#code-example>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DisjointSets</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span>[] _parents;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span>[] _ranks;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Count { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> DisjointSets(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        _parents = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[n];
</span></span><span style=display:flex><span>        _ranks = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[n];
</span></span><span style=display:flex><span>        Count = n;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>var</span> i = <span style=color:#ae81ff>0</span>; i &lt; n; i++) {
</span></span><span style=display:flex><span>            _parents[i] = i;
</span></span><span style=display:flex><span>            _ranks[i] = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Find(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_parents[x] == x) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> x;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// path compression</span>
</span></span><span style=display:flex><span>        _parents[x] = Find(_parents[x]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _parents[x];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Union(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> xRoot = Find(x);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> yRoot = Find(y);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (xRoot == yRoot) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// union by rank</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_ranks[xRoot] &lt; _ranks[yRoot]) {
</span></span><span style=display:flex><span>            _parents[xRoot] = yRoot;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (_ranks[xRoot] &gt; _ranks[yRoot]) {
</span></span><span style=display:flex><span>            _parents[yRoot] = xRoot;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            _parents[yRoot] = xRoot;
</span></span><span style=display:flex><span>            _ranks[xRoot] += <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Count--;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=problems-that-could-be-solved-with-union-find>Problems that could be solved with union find<a hidden class=anchor aria-hidden=true href=#problems-that-could-be-solved-with-union-find>#</a></h4><ul><li><a href=https://leetcode.com/problems/number-of-provinces/>https://leetcode.com/problems/number-of-provinces/</a></li><li><a href=https://leetcode.com/problems/longest-consecutive-sequence/>https://leetcode.com/problems/longest-consecutive-sequence/</a></li><li><a href=https://leetcode.com/problems/accounts-merge/>https://leetcode.com/problems/accounts-merge/</a></li><li><a href=https://leetcode.com/problems/redundant-connection/>https://leetcode.com/problems/redundant-connection/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://danielmititelu.github.io/tags/data-structure/>data-structure</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://danielmititelu.github.io/>Home</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>