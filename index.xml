<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Home</title><link>https://danielmititelu.github.io/</link><description>Recent content on Home</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 19 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://danielmititelu.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Electronics</title><link>https://danielmititelu.github.io/cheatsheets/electronics/</link><pubDate>Sat, 19 Nov 2022 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/cheatsheets/electronics/</guid><description>Electricity is the flow of electrons from the negative side, from a baterry for example, to the positive side of the baterry. The negative side is called anode and has a surplus of electrons and the positive side is called cathode and has a deficit of electrons.
Electric Current Symbol is I from the french phrase intensité du courant, (current intensity) and it is measured in Amps(A). Electric Current is the amount of electrons that flows through a conductor at the rate of 1 Coulomb (6.</description></item><item><title>Dijkstra's Algorithm</title><link>https://danielmititelu.github.io/algorithms/dijkstra-algorithm/</link><pubDate>Mon, 10 Oct 2022 19:40:42 +0300</pubDate><guid>https://danielmititelu.github.io/algorithms/dijkstra-algorithm/</guid><description>Greedy algorithm used to find the shortest path in a weighted graph.
Undirected Single source shortest paths with positive integer weights in linear time
Time complexity: O(V + Elog(E))
Space complexity: O(V + E)
Restrictions: only for non-decreasing weights (all weights &amp;gt;= 0)
private Dictionary&amp;lt;int, int&amp;gt; Dijkstra( Dictionary&amp;lt;int, List&amp;lt;(int dest, int dist)&amp;gt;&amp;gt; graph, int source /*, int target*/) { var minHeap = new PriorityQueue&amp;lt;(int node, int dist), int&amp;gt;(); var distances = new Dictionary&amp;lt;int, int&amp;gt;(); var visited = new HashSet&amp;lt;int&amp;gt;(); // initialize every node with infinity foreach (var node in graph.</description></item><item><title>Trie</title><link>https://danielmititelu.github.io/data-structures/trie/</link><pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/data-structures/trie/</guid><description>A trie or prefix tree is tree data structure that allows for fast searching of a key or string prefix in a dataset of strings. It is used in word completion like google search or intellisense
Example implementation public class Trie { private Node _root; public Trie() { _root = new Node(); } public void Insert(string word) { var node = _root; foreach(char c in word) { if(!node.Children.ContainsKey(c)) { node.Children[c] = new Node(); } node = node.</description></item><item><title>A few words about bit manipulation</title><link>https://danielmititelu.github.io/blogs/bit-manipulation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/blogs/bit-manipulation/</guid><description>Bit manipulation is not a technique that comes often when writing code especially when dealing with higher level languages, regardless it is useful to understand how computers work behind the scene.
Bit The smallest data use to represent a piece of information in computers are bits and they represent an electrical current that is stored in a memory chip. This bit can either be on or off and the notation 1 and 0 from binary system is used to denote it&amp;rsquo;s state.</description></item><item><title>A few words about Graph theory</title><link>https://danielmititelu.github.io/blogs/graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/blogs/graphs/</guid><description>A graph is a collection of vertices(V) or nodes(N) connected with edges (E)
Types of graphs Trees A graph with V-1 edges is a tree
Binary Trees A tree where each vertices has zero or two children</description></item><item><title>Binary tree traversals</title><link>https://danielmititelu.github.io/algorithms/binary-tree-traversals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/binary-tree-traversals/</guid><description>Preorder traversal Order of visiting: parent -&amp;gt; left child -&amp;gt; right child
Recursive implementation:
public IList&amp;lt;int&amp;gt; PreorderTraversal(TreeNode root) { var result = new List&amp;lt;int&amp;gt;(); Preorder(root, result); return result; } public void Preorder(TreeNode node, IList&amp;lt;int&amp;gt; result) { if(node == null) return; result.Add(node.val); Preorder(node.left, result); Preorder(node.right, result); } Iterative implementation:
public IList&amp;lt;int&amp;gt; PreorderTraversal(TreeNode root) { var res = new List&amp;lt;int&amp;gt;(); if (root == null) return res; var stack = new Stack&amp;lt;TreeNode&amp;gt;(); stack.Push(root); while (stack.</description></item><item><title>Boyer-Moore Voting Algorithm</title><link>https://danielmititelu.github.io/algorithms/voting-algo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/voting-algo/</guid><description>Time complexity : O(n) Space complexity : O(1)
The algorithm counts the majority of votes(elements) in an array by finding a part of the array (suffix) where the first element in array suffix is the majority. It does this by diregarding any prefix where the majority is equal to the minority of votes.
public int MajorityElement(int[] nums) { int count = 0; int candidate = 0; foreach (int num in nums) { if (count == 0) { candidate = num; } count += (num == candidate) ?</description></item><item><title>Cooking</title><link>https://danielmititelu.github.io/drafts/cooking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/drafts/cooking/</guid><description>Rice Ingredients
100g of rice salt and pepper 200ml of water Steps:
Wash the rice 3 to 4 times Boil the water Add the rice in boiling water for 10 minutes with the lid on Stop the fire and leave it with the lid on for 10 minutes</description></item><item><title>Cycle detection</title><link>https://danielmititelu.github.io/algorithms/cycle-detection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/cycle-detection/</guid><description>public enum Colors { White, Gray, Black } public bool HasCycle(int[][] graph, int start, Colors[] colors) { if(colors[start] == Colors.Gray) return true; if(colors[start] == Colors.Black) return false; colors[start] = Colors.Gray; foreach(var neighbor in graph[start]) { if(HasCycle(graph, neighbor, colors)) return true; } colors[start] = Colors.Black; return false; } Problems https://leetcode.com/problems/find-eventual-safe-states</description></item><item><title>Disjoint sets</title><link>https://danielmititelu.github.io/data-structures/disjoint-sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/data-structures/disjoint-sets/</guid><description>Disjoint Sets or Union find is a data structure used for finding relationships between nodes.
For example disjointed sets are ideal for the following scenarios:
find if a person is a direct or indirect friend of another person in a social platform given a list of flights find if there is a way to reach a destination starting from a given city Disjoint Sets or Union find implements 2 methods:</description></item><item><title>Fusion 360</title><link>https://danielmititelu.github.io/cheatsheets/fusion360/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/cheatsheets/fusion360/</guid><description>Display component colors Inspect -&amp;gt; Display component colors
Right click on component -&amp;gt; Cycle component color</description></item><item><title>Gadget mode on raspberry pi</title><link>https://danielmititelu.github.io/raspberrypi/gadget-mode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/raspberrypi/gadget-mode/</guid><description>Gadget mode enables a raspberry pi to be connected and controlled by a computer with only a usb cable
Flash raspberry pi os(the full or lite version) on an SD card and modify the following in the boot folder:
in config.txt add dtoverlay=dwc2 at the end of the file in cmdline.txt add modules-load=dwc2,g_ether after rootwait word create a file name ssh (without extension) You should be able to connect to the pi now:</description></item><item><title>Games</title><link>https://danielmititelu.github.io/drafts/games/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/drafts/games/</guid><description>Hades Death&amp;rsquo;s door Rainbow Six: Siege Destiny 2 Call of duty: Warzone Bastion Transistor Pyre Cyberpunk 2077 Crying Suns Bioshock 1 Biosock 2 Bioshock Infinite Splinter Cell: Blacklist Far Cry 3 Far Cry 4 Far Cry: New Dawn Far Cry 5 Far cry: Blood dragon Thief Styx: Master of Shadows Dishonored Control Ori and the Blind Forest Ori and the Will of the Wisps Morkredd Stealth Inc. 2: A Game of Clones Portal 2 Bridge Constructor: Portal Death Squared Frostpunk Marvel vs Capcom Moonlighter Neon Abyss Mortal Kombat Katana Zero A Plague Tale: Innocence Overcooked 2 Unruly Heroes World war z Vambrace Cold Soul Wasteland 3 Skyrim Shank Lineage 2 Wow Guild wars 2 The elder scrolls online Tera Aion BadNorth Don&amp;rsquo;t starve Together Hearthstone League of Legends Legends of Runeterra Valorant Counter-Strike 1.</description></item><item><title>Graph traversals</title><link>https://danielmititelu.github.io/algorithms/graph-traversals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/graph-traversals/</guid><description>Breadth-first search We scan through the graph level by level starting with the nodes closest to the starting node.
Examples: BFS can only be implemented in iterative manner: public void BFS(Node node) { var queue = new Queue&amp;lt;Node&amp;gt;(); queue.Enqueue(node); while(queue.Count &amp;gt; 0) { const current = queue.Dequeue(); // visit node node.Visited = true; foreach(var child of node.Children) if(!child.Visited) stack.Enqueue(child); } } Depth-first search DFS for short is going to search a graph or matrix by depth first meaning it will pick a direction and go in that direction before coming back to visit other directions</description></item><item><title>Hash map</title><link>https://danielmititelu.github.io/data-structures/hashmap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/data-structures/hashmap/</guid><description>Time complexity: - average case: insert, lookup O(1) - worst case: insert, lookup O(N)
A hash map, hash table or dictionary organizes data in key/value pairs with constant lookup time for the keys. It is similar to an array where indexes are used to access values but the key difference (no pun intended) is that any type of object can be used as the key and not just integers.
In fact hash tables are built with array as the backing field but in order to support strings or custom object in keys a hashing function is used to convert the string/custom object to an integer index.</description></item><item><title>Heap</title><link>https://danielmititelu.github.io/data-structures/heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/data-structures/heap/</guid><description>A heap is a complete binary tree where the any given node is smaller/bigger than it&amp;rsquo;s descendents depending if it&amp;rsquo;s a min/max heap
Heap represented as array A heap can easily be represented as an array:
add in array level by level if a given node is at index i to find the parent of a node: p = (i - 1) / 2 (floor value of i/2) left chlid = 2 * i + 1 right child = 2 * i + 2 all leaf nodes are in the last half of the array Insert a value in the heap add element at the end of array compare with parent and swap if it&amp;rsquo;s smaller/bigger repeat for all parents of that node Extract min/max value from heap get value from root bring the right-most leaf(last element of array) in the root push the element down by comparing with it&amp;rsquo;s children and swapping if neccesary (or [[Heapify]]) public class MinHeap { private List&amp;lt;int&amp;gt; _heap; public MinHeap() { _heap = new List&amp;lt;int&amp;gt;(); } public void Insert(int value) { _heap.</description></item><item><title>Jokes</title><link>https://danielmititelu.github.io/drafts/jokes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/drafts/jokes/</guid><description>Dad jokes I asked my date to meet me at the gym today. She didn’t show up.
That’s when I knew we weren’t gonna work out.
Today a man knocked on my door and asked for a small donation to the local swimming pool.
I gave him a glass of water.</description></item><item><title>Kruskal's Algorithm</title><link>https://danielmititelu.github.io/algorithms/kruskal-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/kruskal-algorithm/</guid><description>Greedy alghorithm used to find the minimum spanning tree of a given graph
Time complexity: O(Elog(E))
Space complexity: O(E + V)
Minimum spanning tree A Minimum spanning tree(MST for short) is a subgraph of a cyclic, undirected graph that will connected all the vertices and contain no cycles.
Number of edges of the MST is equal to V - 1 where V is the number of vertices of the bigger graph</description></item><item><title>Linux commands cheat sheet</title><link>https://danielmititelu.github.io/cheatsheets/linux-commands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/cheatsheets/linux-commands/</guid><description>Find ip address hostname -I Find port listeners sudo netstat -pna | grep 80</description></item><item><title>Multi-source Bread-first search</title><link>https://danielmititelu.github.io/algorithms/multi-source-bfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/multi-source-bfs/</guid><description>Leetcode problems https://leetcode.com/problems/01-matrix/ https://leetcode.com/problems/rotting-oranges/</description></item><item><title>Plant watering system part 1 - Prototype</title><link>https://danielmititelu.github.io/projects/platn-watering-system/part-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/projects/platn-watering-system/part-1/</guid><description>This project is meant to keep my plants healthy while I go on vacations.
Parts required Raspberry Pi Zero (will work with any Raspberry Pi) micro usb power supply 3v-5v pump small hose for the pump 5v relay wires Wiring diagram Relay inputs:
NO = normally opened NC = normally closed CO = common DC- = ground DC+ = 5V signal IN = signal Code Simple python code to send a signal to pin 8 for 0.</description></item><item><title>Plant watering system part 2 - Switching to Raspberry Pi Pico</title><link>https://danielmititelu.github.io/projects/platn-watering-system/part-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/projects/platn-watering-system/part-2/</guid><description>A linux computer like the Raspberry Pi Zero used in the prototype is overkill for this application and a more suitable candidate is a microcontroller like the Raspberry Pi Pico.
Wiring diagram Code I used Arduino IDE to write a simple program that will open the pump for 10 seconds every 2 days.
const unsigned long SECOND = 1000; const unsigned long MINUTE = SECOND * 60; const unsigned long HOUR = MINUTE * 60; const unsigned long DAY = HOUR * 24; int pin = 16; void setup() { pinMode(pin, OUTPUT); } void loop() { openPump(); delay(2 * DAY); } void openPump() { digitalWrite(pin, HIGH); delay(10 * SECOND); digitalWrite(pin, LOW); } Result Useful links https://datasheets.</description></item><item><title>Quickselect</title><link>https://danielmititelu.github.io/algorithms/quick-select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/quick-select/</guid><description>Quick select or Hoare&amp;rsquo;s selection algorithm Time complexity: - average case O(N) - worst case O(N^2)
Algoritm steps:
figure out k-th index(smallest: k, biggest: n - k) add 2 pointers (left and right) for the start and end of the array, similar to binary search while left is smaller than right pick a random index as pivot and partition: save the pivot in the right pointer starting from left with 2 pointers: storeIndex and i: move i forword untill it reaches the right pointer, every time i finds a value smaller than the pivot, swap it with storeIndex and increment storeIndex at the end swap storeIndex with the pivot stored in right pointer return storeIndex, this is our pivot in it&amp;rsquo;s final ordered position similar to binary search compare pivot index with the k-th index: if they are equal then we found the k-th element if pivot index is bigger, seach in the left part of the pivot where there are smaller values if pivot index is smaller, search in the right part int FindKthLargest(int[] nums, int k) { var kthIndex = nums.</description></item><item><title>SSH key-based auth</title><link>https://danielmititelu.github.io/raspberrypi/ssh-key-auth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/raspberrypi/ssh-key-auth/</guid><description> Generate a public/private key pair and ssh-keygen # add `~/.ssh/pi_rsa` when prompted for which file to save the key Move the public key to the raspberry pi ssh-copy-id -i ~/.ssh/pi_rsa.pub pi@raspberrypi.local SSH into the raspberry pi ssh pi@raspberrypi.local</description></item><item><title>Svelte cheat sheet</title><link>https://danielmititelu.github.io/cheatsheets/svelte/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/cheatsheets/svelte/</guid><description>&amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; export let componentProp; export { className as class }; let className = &amp;#34;&amp;#34;; let x = 7; let array = [1, 2, 3, 4]; &amp;lt;/script&amp;gt; &amp;lt;div class:disabled class=&amp;#34;{className ? className : &amp;#39;&amp;#39;}&amp;#34;&amp;gt; &amp;lt;div&amp;gt;Component property: {componentProp}&amp;lt;/div&amp;gt; &amp;lt;!-- component children --&amp;gt; &amp;lt;slot /&amp;gt; {#if x &amp;gt; 10} &amp;lt;p&amp;gt;{x} is greater than 10&amp;lt;/p&amp;gt; {:else if x &amp;lt; 5&amp;gt;} &amp;lt;p&amp;gt;{x} is less than 5&amp;lt;/p&amp;gt; {:else} &amp;lt;p&amp;gt;{x} is between 5 and 10&amp;lt;/p&amp;gt; {/if} {#each array as elem} &amp;lt;div&amp;gt;{elem}&amp;lt;/div&amp;gt; {/each} &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .</description></item><item><title>System design</title><link>https://danielmititelu.github.io/blogs/system-design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/blogs/system-design/</guid><description>Databases Database management systems (DBMS) which are usually referred to as just databases are a piece of software that are used stores data in an organized way and offer an API to interact with it.
Depending on the way data is organized and accessed there can be different databases paradigm and we will explore a few of them here.
Relational databases Examples: PostgreSQL, MySql, Oracle, Microsoft SQL Server
The most common way to store data is using tables with rows, columns and having relations between them.</description></item><item><title>Three way partitioning</title><link>https://danielmititelu.github.io/algorithms/three-way-partitioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/three-way-partitioning/</guid><description>A partition strategy that is sometime used in quicksort.
Code example Dutch national flag problem // Dutch national flag problem (partition array into 3 parts: red, white, blue) // 0 -&amp;gt; red, 1 -&amp;gt; white, 2 -&amp;gt; blue void SortColors(int[] nums) { int red = 0, white = 0, blue = nums.Length - 1; // Traverse the array until we hit the blue part while(white &amp;lt;= blue) { // if the white iterator hit a red color // swap it with the red iterator and increment it // and the white iterator if(nums[white] == 0) { Swap(nums, red, white); red++; white++; } // if the white iterator hit a blue color // swap it with the blue iterator and // decrement the blue iterator else if(nums[white] == 2) { Swap(nums, white, blue); blue--; } // if white iterator hit a white color // it&amp;#39;s already in the right place // so just increase the white iterator else { white++; } } } void Swap(int[] nums, int left, int i) { int temp = nums[left]; nums[left] = nums[i]; nums[i] = temp; } Partition around a range // Function to partition the array around the range such // that array is divided into three parts.</description></item><item><title>Topological sort</title><link>https://danielmititelu.github.io/algorithms/topological-sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/algorithms/topological-sort/</guid><description>Time Complexity: O(V+E) // V = vertex (or node), E = edge
Sort a graph so that any node on the left will point only to the nodes in the right
cannot be done for graphs that have a cycle should be a DAG(directed acyclic graph) Khan&amp;rsquo;s algorithm
private List&amp;lt;int&amp;gt; TopologicalSort(Dictionary&amp;lt;int, List&amp;lt;int&amp;gt;&amp;gt; graph) { var indegrees = CountIndegrees(graph); var queue = new Queue&amp;lt;int&amp;gt;(); foreach(var (course, count) in indegrees) { if(count == 0) { queue.</description></item><item><title>Visual Studio code cheat sheet</title><link>https://danielmititelu.github.io/cheatsheets/vscode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://danielmititelu.github.io/cheatsheets/vscode/</guid><description>Focus explorer ctrl + shift + e cmd + shift + e Hide sidebar ctrl + b cmd + b Show terminal ctrl + ` cmd + `</description></item></channel></rss>